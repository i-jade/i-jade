{"pageProps":{"note":{"id":"xh52bggd05ofgonrdag8z5u","title":"Stack","desc":"","updated":1670242188649,"created":1670066099552,"custom":{},"fname":"self.reading.grace.data-structure.stack","type":"note","vault":{"fsPath":".","selfContained":true,"name":"Notes"},"contentHash":"86e4d167dd37bebe4d0759b553b3a014","links":[{"type":"wiki","from":{"fname":"self.reading.grace.data-structure.stack","id":"xh52bggd05ofgonrdag8z5u","vaultName":"Notes"},"value":"tags.Data-Structure","alias":"#Data-Structure","position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":16,"offset":16},"indent":[]},"xvault":false,"to":{"fname":"tags.Data-Structure"}},{"type":"wiki","from":{"fname":"self.reading.grace.data-structure.stack","id":"xh52bggd05ofgonrdag8z5u","vaultName":"Notes"},"value":"tags.Stack","alias":"#Stack","position":{"start":{"line":2,"column":17,"offset":17},"end":{"line":2,"column":23,"offset":23},"indent":[]},"xvault":false,"to":{"fname":"tags.Stack"}}],"anchors":{"相关题目":{"type":"header","text":"相关题目","value":"相关题目","line":15,"column":0,"depth":3}},"children":[],"parent":"kyvtf0hst75lwr1iw9glvhr","data":{}},"body":"<h1 id=\"stack\">Stack<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#stack\"></a></h1>\n<p><a title=\"Private\" href=\"https://wiki.dendron.so/notes/hfyvYGJZQiUwQaaxQO27q.html\" target=\"_blank\" class=\"private\">#Data-Structure (Private)</a> <a title=\"Private\" href=\"https://wiki.dendron.so/notes/hfyvYGJZQiUwQaaxQO27q.html\" target=\"_blank\" class=\"private\">#Stack (Private)</a></p>\n<ol>\n<li>\n<p>后进先出，先进后出，操作受限的线性表</p>\n</li>\n<li>\n<p>数组实现的栈=顺序栈，链表实现的栈=链式栈</p>\n<ol>\n<li>栈的相关 leetcode 题目：20,155,232,844,224,682,496.</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"相关题目\">相关题目<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#相关题目\"></a></h3>\n<ol>\n<li>20 题目描述：有效的括号,给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。</li>\n</ol>\n<pre class=\"language-c#\"><code class=\"language-c#\"> public class Solution {\n     public bool IsValid(string s) {\n         Stack&#x3C;char> sc = new Stack&#x3C;char>();\n         Dictionary&#x3C;char, char> otherChar = new Dictionary&#x3C;char, char>() { { '(', ')' }, { '[',']' },{ '{','}'} };\n         foreach( var item in s)\n         {\n             if(otherChar.ContainsKey(item)) sc.Push(item);\n             else\n             {\n                 if (sc.Count == 0) return false;\n                 char c = sc.Pop();\n                 if (otherChar[c] != item) return false;\n             }\n\n         }\n         return sc.Count == 0;\n\n     }\n }\n</code></pre>\n<ol start=\"2\">\n<li>155 题描述：设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</li>\n</ol>\n<p>实现 MinStack 类:</p>\n<ul>\n<li>MinStack() 初始化堆栈对象。</li>\n<li>void push(int val) 将元素 val 推入堆栈。</li>\n<li>void pop() 删除堆栈顶部的元素。</li>\n<li>int top() 获取堆栈顶部的元素。</li>\n<li>int getMin() 获取堆栈中的最小元素。</li>\n</ul>\n<pre class=\"language-c#\"><code class=\"language-C#\">public class MinStack {\n\n    private int?[] _array;\n    private int _size = 0;\n\n    private const int _defaultCapacity = 10;\n\n    public MinStack()\n    {\n        _array = new int?[_defaultCapacity];\n    }\n\n    public void Push(int val)\n    {\n        if (_array.Length == _size)\n        {\n            int?[] newArray = new int?[_size * 2];\n            Array.Copy(_array, newArray, _size);\n            _array = newArray;\n        }\n        _array[_size++] = val;\n    }\n\n    public void Pop()\n    {\n        _array[--_size] = null;\n    }\n\n    public int Top()\n    {\n        return (int)_array[_size - 1];\n    }\n\n    public int GetMin()\n    {\n        return (int)_array.Min();\n    }\n}\n</code></pre>\n<ul>\n<li>占用内存最小的解法</li>\n</ul>\n<pre class=\"language-c#\"><code class=\"language-C#\">public class MinStack {\n\n    Stack&#x3C;int> stack;\n    Stack&#x3C;int> minStack;\n\n    public MinStack()\n    {\n        stack= new Stack&#x3C;int>();\n        minStack= new Stack&#x3C;int>();\n    }\n\n    public void Push(int val)\n    {\n        stack.Push(val);\n        if(minStack.Count == 0 || minStack.Peek() >= val)\n        {\n            minStack.Push(val);\n        }\n    }\n\n    public void Pop()\n    {\n        if(minStack.Count!= 0 &#x26;&#x26; stack.Pop() == minStack.Peek())\n        {\n            minStack.Pop();\n        }\n    }\n\n    public int Top()\n    {\n        return stack.Peek();\n    }\n\n    public int GetMin()\n    {\n        return minStack.Peek();\n    }\n}\n\n</code></pre>\n<ol start=\"3\">\n<li>232 题，用栈实现队列。题目描述：请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</li>\n</ol>\n<p>实现 MyQueue 类：</p>\n<ul>\n<li>\n<p>void push(int x) 将元素 x 推到队列的末尾</p>\n</li>\n<li>\n<p>int pop() 从队列的开头移除并返回元素</p>\n</li>\n<li>\n<p>int peek() 返回队列开头的元素</p>\n</li>\n<li>\n<p>boolean empty() 如果队列为空，返回 true ；否则，返回 false\n说明：</p>\n</li>\n<li>\n<p>你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。</p>\n</li>\n</ul>\n<pre class=\"language-c#\"><code class=\"language-C#\">public class MyQueue {\n\n    Stack&#x3C;int> leftStack;\n    Stack&#x3C;int> rightStack;\n\n    public MyQueue()\n    {\n        leftStack= new Stack&#x3C;int>();\n        rightStack= new Stack&#x3C;int>();\n    }\n\n    public void Push(int x)\n    {\n        if(leftStack.Count==0) leftStack.Push(x);\n        else\n        {\n            while(leftStack.Count != 0)\n            {\n                int v = leftStack.Pop();\n                rightStack.Push(v);\n            }\n            leftStack.Push(x);\n            while(rightStack.Count != 0)\n            {\n                int v = rightStack.Pop();\n                leftStack.Push(v);\n            }\n        }\n\n        //另一种解题思路\n        while(leftStack.Count !=0) rightStack.Push(leftStack.Pop());\n        leftStack.Push(x);\n        while(rightStack.Count != 0) leftStack.Push(rightStack.Pop());\n    }\n\n    public int Pop()\n    {\n        return leftStack.Pop();\n    }\n\n    public int Peek()\n    {\n        return leftStack.Peek();\n    }\n\n    public bool Empty()\n    {\n        return leftStack.Count == 0;\n    }\n}\n</code></pre>\n<p>844 题目：给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。</p>\n<p>注意：如果对空文本输入退格字符，文本继续为空。\n示例 1：</p>\n<p>输入：s = \"ab#c\", t = \"ad#c\"\n输出：true\n解释：s 和 t 都会变成 \"ac\"。\n示例 2：</p>\n<p>输入：s = \"ab##\", t = \"c#d#\"\n输出：true\n解释：s 和 t 都会变成 \"\"。\n示例 3：</p>\n<p>输入：s = \"a#c\", t = \"b\"\n输出：false\n解释：s 会变成 \"c\"，但 t 仍然是 \"b\"。</p>\n<pre class=\"language-c#\"><code class=\"language-C#\">public class Solution {\n    public bool BackspaceCompare(string s, string t) {\n        Stack&#x3C;char> l = new Stack&#x3C;char>();\n        Stack&#x3C;char> r = new Stack&#x3C;char>();\n\n        foreach(var item in s)\n        {\n            if(item == '#'){\n                 if(l.Count > 0) l.Pop();\n            }\n            else l.Push(item);\n        }\n        foreach(var item in t)\n        {\n            if (item == '#' ){\n                if(r.Count > 0) r.Pop();\n            }\n            else r.Push(item);\n        }\n        if (l.Count != r.Count) return false;\n        while(l.Count > 0){\n            if(l.Pop() != r.Pop()) return false;\n        }\n        return true ;\n    }\n}\n\n</code></pre>\n<p>题目 682，棒球比赛：你现在是一场采用特殊赛制棒球比赛的记录员。这场比赛由若干回合组成，过去几回合的得分可能会影响以后几回合的得分。</p>\n<p>比赛开始时，记录是空白的。你会得到一个记录操作的字符串列表 ops，其中 ops[i] 是你需要记录的第 i 项操作，ops 遵循下述规则：</p>\n<p>整数 x - 表示本回合新获得分数 x\n\"+\" - 表示本回合新获得的得分是前两次得分的总和。题目数据保证记录此操作时前面总是存在两个有效的分数。\n\"D\" - 表示本回合新获得的得分是前一次得分的两倍。题目数据保证记录此操作时前面总是存在一个有效的分数。\n\"C\" - 表示前一次得分无效，将其从记录中移除。题目数据保证记录此操作时前面总是存在一个有效的分数。\n请你返回记录中所有得分的总和。</p>\n<pre class=\"language-c#\"><code class=\"language-c#\">public int CalPoints(string[] operations) {\n        Stack&#x3C;int> stack = new Stack&#x3C;int>();\n        foreach (var s in operations)\n        {\n            if (s == \"+\")\n            {\n                int num1 = stack.Pop();\n                int num2 = stack.Peek();\n                stack.Push(num1);\n                stack.Push(num1 + num2);\n            }\n            else if (s == \"D\")\n            {\n\n                int num1 = stack.Peek();\n                stack.Push(2 * num1);\n            }\n            else if (s == \"C\")\n            {\n\n                stack.Pop();\n            }\n            else stack.Push(int.Parse(s));\n        }\n        int sum = 0;\n        while (stack.Any())\n        {\n            sum += stack.Pop();\n        }\n        return sum;\n    }\n</code></pre>\n<p>题目 496，下一个更大元素：\nnums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。</p>\n<p>给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中 nums1 是 nums2 的子集。</p>\n<p>对于每个 0 &#x3C;= i &#x3C; nums1.length ，找出满足 nums1[i] == nums2[j] 的下标 j ，并且在 nums2 确定 nums2[j] 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 -1 。</p>\n<p>返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i] 是如上所述的 下一个更大元素 。</p>\n<p>示例 1：</p>\n<p>输入：nums1 = [4,1,2], nums2 = [1,3,4,2].\n输出：[-1,3,-1]\n解释：nums1 中每个值的下一个更大元素如下所述：</p>\n<ul>\n<li>4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。</li>\n<li>1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。</li>\n<li>2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。</li>\n</ul>\n<pre class=\"language-c#\"><code class=\"language-c#\">public int[] NextGreaterElement(int[] nums1, int[] nums2) {\n        List&#x3C;int> stack = new List&#x3C;int>();\n        int n1 = nums1.Length;\n        int n2 = nums2.Length;\n        for (int i = 0; i &#x3C; n1; i++)\n        {\n            int max = -1;\n            int find = 0;\n            int value = nums1[i];\n\n            for ( int j = 0 ; j &#x3C; n2; j++)\n            {\n                if (value == nums2[j])\n                {\n                    find = j;\n                    break;\n                };\n            }\n            if (find != n2)\n            {\n                for ( int k = find; k &#x3C; n2; k++)\n                {\n                    if (value &#x3C; nums2[k])\n                    {\n                        max = nums2[k];\n                        break;\n                    }\n                }\n            }\n            stack.Add(max);\n        }\n        return stack.ToArray();\n    }\n</code></pre>","noteIndex":{"id":"c1cwtzujmgfsd4mq3t3tytu","title":"Root","desc":"","updated":1670036340835,"created":1670036340835,"custom":{"nav_order":0,"permalink":"/"},"fname":"root","type":"note","vault":{"fsPath":".","selfContained":true,"name":"Notes"},"contentHash":"e2031e0d4f5f68229f977757318dd889","links":[],"anchors":{"welcome-to-dendron":{"type":"header","text":"Welcome to Dendron","value":"welcome-to-dendron","line":7,"column":0,"depth":1},"lookup":{"type":"header","text":"Lookup","value":"lookup","line":11,"column":0,"depth":2}},"children":["6dtg3w55w1x7r0sawmob7lv","cjgvkorp7u78p38mx3ptzlo","d0xazr16kuzwxb3uao60g8m","k1twbj4e5z32nbsnio3j6zy","n99az6y3n94r0t8e1crppv2","43t92vxhgipu9o19mdb3mfn"],"parent":null,"data":{},"body":"# Welcome to Dendron\n\nThis is the root of your dendron vault. If you decide to publish your entire vault, this will be your landing page. You are free to customize any part of this page except the frontmatter on top.\n\n## Lookup\n\nThis section contains useful links to related resources.\n\n- [Getting Started Guide](https://link.dendron.so/6b25)\n- [Discord](https://link.dendron.so/6b23)\n- [Home Page](https://wiki.dendron.so/)\n- [Github](https://link.dendron.so/6b24)\n- [Developer Docs](https://docs.dendron.so/)\n"},"collectionChildren":null,"customHeadContent":null,"config":{"version":5,"dev":{"enablePreviewV2":true,"enableSelfContainedVaults":true},"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":true,"vaultSelectionModeOnCreate":"smart","leaveTrace":false,"bubbleUpCreateNew":true,"fuzzThreshold":0.2}},"randomNote":{},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"copyNoteLink":{"aliasMode":"title"},"templateHierarchy":"template"},"workspace":{"vaults":[{"fsPath":".","selfContained":true,"name":"Notes"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"task":{"name":"task","dateFormat":"y.MM.dd","addBehavior":"asOwnDomain","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"taskCompleteStatus":["done","x"],"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link"},"graph":{"zoomSpeed":1,"createStub":false},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"enableUserTags":true,"enableHashTags":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":false,"enableEditorDecorations":true,"maxPreviewsCached":10,"maxNoteLength":204800,"enableFullHierarchyNoteTitle":false},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enablePrettyRefs":true,"enableKatex":true,"automaticallyShowPreview":false},"publishing":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"copyAssets":true,"siteHierarchies":["root"],"writeStubs":false,"siteRootDir":"docs","seo":{"title":"Dendron","description":"Personal Knowledge Space"},"github":{"enableEditLink":true,"editLinkText":"Edit this page on GitHub","editBranch":"main","editViewMode":"tree"},"enableSiteLastModified":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enableRandomlyColoredTags":true,"enableTaskNotes":true,"enablePrettyLinks":true,"searchMode":"search","siteUrl":"https://i-jade.github.io","siteFaviconPath":"favicon.ico","siteIndex":"root"}}},"__N_SSG":true}