<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>Stack</title><meta name="robots" content="index,follow"/><meta name="googlebot" content="index,follow"/><meta name="description" content="Personal Knowledge Space"/><meta property="og:title" content="Stack"/><meta property="og:description" content="Personal Knowledge Space"/><meta property="og:url" content="https://i-jade.github.io/notes/xh52bggd05ofgonrdag8z5u/"/><meta property="og:type" content="article"/><meta property="article:published_time" content="2022/12/3"/><meta property="article:modified_time" content="2022/12/5"/><link rel="canonical" href="https://i-jade.github.io/notes/xh52bggd05ofgonrdag8z5u/"/><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/fec53809098c12ff.css" as="style"/><link rel="stylesheet" href="/_next/static/css/fec53809098c12ff.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-e039b87ca005d039.js" defer=""></script><script src="/_next/static/chunks/framework-28c999baf2863c3d.js" defer=""></script><script src="/_next/static/chunks/main-104451f3d1a5c4bc.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6b338472289fe290.js" defer=""></script><script src="/_next/static/chunks/935-4dee79e80b8641c6.js" defer=""></script><script src="/_next/static/chunks/6-50972def09142ee2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5Bid%5D-78d472fa3b924116.js" defer=""></script><script src="/_next/static/UBg_0AtPYlRIOJ6te7oHW/_buildManifest.js" defer=""></script><script src="/_next/static/UBg_0AtPYlRIOJ6te7oHW/_ssgManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><section class="ant-layout" style="width:100%;min-height:100%"><header class="ant-layout-header" style="position:fixed;isolation:isolate;z-index:1;width:100%;border-bottom:1px solid #d4dadf;height:64px;padding:0 24px 0 2px"><div class="ant-row ant-row-center" style="max-width:992px;justify-content:space-between;margin:0 auto"><div style="display:flex" class="ant-col ant-col-xs-20 ant-col-sm-4"></div><div class="ant-col gutter-row ant-col-xs-0 ant-col-sm-20 ant-col-md-20 ant-col-lg-19"><div class="ant-select ant-select-lg ant-select-auto-complete ant-select-single ant-select-allow-clear ant-select-show-search" style="width:100%"><div class="ant-select-selector"><span class="ant-select-selection-search"><input type="search" autoComplete="off" class="ant-select-selection-search-input" role="combobox" aria-haspopup="listbox" aria-owns="undefined_list" aria-autocomplete="list" aria-controls="undefined_list" aria-activedescendant="undefined_list_0" value=""/></span><span class="ant-select-selection-placeholder">For full text search please use the &#x27;?&#x27; prefix. e.g. ? Onboarding</span></div></div></div><div style="display:none;align-items:center;justify-content:center" class="ant-col ant-col-xs-4 ant-col-sm-4 ant-col-md-0 ant-col-lg-0"><span role="img" aria-label="menu" style="font-size:24px" tabindex="-1" class="anticon anticon-menu"><svg viewBox="64 64 896 896" focusable="false" data-icon="menu" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M904 160H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0 624H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0-312H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8z"></path></svg></span></div></div></header><section class="ant-layout" style="margin-top:64px;display:flex;flex-direction:row"><div class="site-layout-sidebar" style="flex:0 0 auto;width:calc(max((100% - 992px) / 2, 0px) + 200px);min-width:200px;padding-left:calc((100% - 992px) / 2)"><aside class="ant-layout-sider ant-layout-sider-dark" style="position:fixed;overflow:auto;height:calc(100vh - 64px);background-color:transparent;flex:0 0 200px;max-width:200px;min-width:200px;width:200px"><div class="ant-layout-sider-children"></div></aside></div><main class="ant-layout-content side-layout-main" style="max-width:1200px;min-width:0;display:block"><div style="padding:0 24px"><div class="main-content" role="main"><div class="ant-row"><div class="ant-col ant-col-24"><div class="ant-row" style="margin-left:-10px;margin-right:-10px"><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-24 ant-col-md-18"><div><h1 id="stack">Stack<a aria-hidden="true" class="anchor-heading icon-link" href="#stack"></a></h1>
<p><a title="Private" href="https://wiki.dendron.so/notes/hfyvYGJZQiUwQaaxQO27q.html" target="_blank" class="private">#Data-Structure (Private)</a> <a title="Private" href="https://wiki.dendron.so/notes/hfyvYGJZQiUwQaaxQO27q.html" target="_blank" class="private">#Stack (Private)</a></p>
<ol>
<li>
<p>后进先出，先进后出，操作受限的线性表</p>
</li>
<li>
<p>数组实现的栈=顺序栈，链表实现的栈=链式栈</p>
<ol>
<li>栈的相关 leetcode 题目：20,155,232,844,224,682,496.</li>
</ol>
</li>
</ol>
<h3 id="相关题目">相关题目<a aria-hidden="true" class="anchor-heading icon-link" href="#相关题目"></a></h3>
<ol>
<li>20 题目描述：有效的括号,给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。</li>
</ol>
<pre class="language-c#"><code class="language-c#"> public class Solution {
     public bool IsValid(string s) {
         Stack&#x3C;char> sc = new Stack&#x3C;char>();
         Dictionary&#x3C;char, char> otherChar = new Dictionary&#x3C;char, char>() { { '(', ')' }, { '[',']' },{ '{','}'} };
         foreach( var item in s)
         {
             if(otherChar.ContainsKey(item)) sc.Push(item);
             else
             {
                 if (sc.Count == 0) return false;
                 char c = sc.Pop();
                 if (otherChar[c] != item) return false;
             }

         }
         return sc.Count == 0;

     }
 }
</code></pre>
<ol start="2">
<li>155 题描述：设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</li>
</ol>
<p>实现 MinStack 类:</p>
<ul>
<li>MinStack() 初始化堆栈对象。</li>
<li>void push(int val) 将元素 val 推入堆栈。</li>
<li>void pop() 删除堆栈顶部的元素。</li>
<li>int top() 获取堆栈顶部的元素。</li>
<li>int getMin() 获取堆栈中的最小元素。</li>
</ul>
<pre class="language-c#"><code class="language-C#">public class MinStack {

    private int?[] _array;
    private int _size = 0;

    private const int _defaultCapacity = 10;

    public MinStack()
    {
        _array = new int?[_defaultCapacity];
    }

    public void Push(int val)
    {
        if (_array.Length == _size)
        {
            int?[] newArray = new int?[_size * 2];
            Array.Copy(_array, newArray, _size);
            _array = newArray;
        }
        _array[_size++] = val;
    }

    public void Pop()
    {
        _array[--_size] = null;
    }

    public int Top()
    {
        return (int)_array[_size - 1];
    }

    public int GetMin()
    {
        return (int)_array.Min();
    }
}
</code></pre>
<ul>
<li>占用内存最小的解法</li>
</ul>
<pre class="language-c#"><code class="language-C#">public class MinStack {

    Stack&#x3C;int> stack;
    Stack&#x3C;int> minStack;

    public MinStack()
    {
        stack= new Stack&#x3C;int>();
        minStack= new Stack&#x3C;int>();
    }

    public void Push(int val)
    {
        stack.Push(val);
        if(minStack.Count == 0 || minStack.Peek() >= val)
        {
            minStack.Push(val);
        }
    }

    public void Pop()
    {
        if(minStack.Count!= 0 &#x26;&#x26; stack.Pop() == minStack.Peek())
        {
            minStack.Pop();
        }
    }

    public int Top()
    {
        return stack.Peek();
    }

    public int GetMin()
    {
        return minStack.Peek();
    }
}

</code></pre>
<ol start="3">
<li>232 题，用栈实现队列。题目描述：请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</li>
</ol>
<p>实现 MyQueue 类：</p>
<ul>
<li>
<p>void push(int x) 将元素 x 推到队列的末尾</p>
</li>
<li>
<p>int pop() 从队列的开头移除并返回元素</p>
</li>
<li>
<p>int peek() 返回队列开头的元素</p>
</li>
<li>
<p>boolean empty() 如果队列为空，返回 true ；否则，返回 false
说明：</p>
</li>
<li>
<p>你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。</p>
</li>
</ul>
<pre class="language-c#"><code class="language-C#">public class MyQueue {

    Stack&#x3C;int> leftStack;
    Stack&#x3C;int> rightStack;

    public MyQueue()
    {
        leftStack= new Stack&#x3C;int>();
        rightStack= new Stack&#x3C;int>();
    }

    public void Push(int x)
    {
        if(leftStack.Count==0) leftStack.Push(x);
        else
        {
            while(leftStack.Count != 0)
            {
                int v = leftStack.Pop();
                rightStack.Push(v);
            }
            leftStack.Push(x);
            while(rightStack.Count != 0)
            {
                int v = rightStack.Pop();
                leftStack.Push(v);
            }
        }

        //另一种解题思路
        while(leftStack.Count !=0) rightStack.Push(leftStack.Pop());
        leftStack.Push(x);
        while(rightStack.Count != 0) leftStack.Push(rightStack.Pop());
    }

    public int Pop()
    {
        return leftStack.Pop();
    }

    public int Peek()
    {
        return leftStack.Peek();
    }

    public bool Empty()
    {
        return leftStack.Count == 0;
    }
}
</code></pre>
<p>844 题目：给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。</p>
<p>注意：如果对空文本输入退格字符，文本继续为空。
示例 1：</p>
<p>输入：s = "ab#c", t = "ad#c"
输出：true
解释：s 和 t 都会变成 "ac"。
示例 2：</p>
<p>输入：s = "ab##", t = "c#d#"
输出：true
解释：s 和 t 都会变成 ""。
示例 3：</p>
<p>输入：s = "a#c", t = "b"
输出：false
解释：s 会变成 "c"，但 t 仍然是 "b"。</p>
<pre class="language-c#"><code class="language-C#">public class Solution {
    public bool BackspaceCompare(string s, string t) {
        Stack&#x3C;char> l = new Stack&#x3C;char>();
        Stack&#x3C;char> r = new Stack&#x3C;char>();

        foreach(var item in s)
        {
            if(item == '#'){
                 if(l.Count > 0) l.Pop();
            }
            else l.Push(item);
        }
        foreach(var item in t)
        {
            if (item == '#' ){
                if(r.Count > 0) r.Pop();
            }
            else r.Push(item);
        }
        if (l.Count != r.Count) return false;
        while(l.Count > 0){
            if(l.Pop() != r.Pop()) return false;
        }
        return true ;
    }
}

</code></pre>
<p>题目 682，棒球比赛：你现在是一场采用特殊赛制棒球比赛的记录员。这场比赛由若干回合组成，过去几回合的得分可能会影响以后几回合的得分。</p>
<p>比赛开始时，记录是空白的。你会得到一个记录操作的字符串列表 ops，其中 ops[i] 是你需要记录的第 i 项操作，ops 遵循下述规则：</p>
<p>整数 x - 表示本回合新获得分数 x
"+" - 表示本回合新获得的得分是前两次得分的总和。题目数据保证记录此操作时前面总是存在两个有效的分数。
"D" - 表示本回合新获得的得分是前一次得分的两倍。题目数据保证记录此操作时前面总是存在一个有效的分数。
"C" - 表示前一次得分无效，将其从记录中移除。题目数据保证记录此操作时前面总是存在一个有效的分数。
请你返回记录中所有得分的总和。</p>
<pre class="language-c#"><code class="language-c#">public int CalPoints(string[] operations) {
        Stack&#x3C;int> stack = new Stack&#x3C;int>();
        foreach (var s in operations)
        {
            if (s == "+")
            {
                int num1 = stack.Pop();
                int num2 = stack.Peek();
                stack.Push(num1);
                stack.Push(num1 + num2);
            }
            else if (s == "D")
            {

                int num1 = stack.Peek();
                stack.Push(2 * num1);
            }
            else if (s == "C")
            {

                stack.Pop();
            }
            else stack.Push(int.Parse(s));
        }
        int sum = 0;
        while (stack.Any())
        {
            sum += stack.Pop();
        }
        return sum;
    }
</code></pre>
<p>题目 496，下一个更大元素：
nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。</p>
<p>给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中 nums1 是 nums2 的子集。</p>
<p>对于每个 0 &#x3C;= i &#x3C; nums1.length ，找出满足 nums1[i] == nums2[j] 的下标 j ，并且在 nums2 确定 nums2[j] 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 -1 。</p>
<p>返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i] 是如上所述的 下一个更大元素 。</p>
<p>示例 1：</p>
<p>输入：nums1 = [4,1,2], nums2 = [1,3,4,2].
输出：[-1,3,-1]
解释：nums1 中每个值的下一个更大元素如下所述：</p>
<ul>
<li>4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。</li>
<li>1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。</li>
<li>2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。</li>
</ul>
<pre class="language-c#"><code class="language-c#">public int[] NextGreaterElement(int[] nums1, int[] nums2) {
        List&#x3C;int> stack = new List&#x3C;int>();
        int n1 = nums1.Length;
        int n2 = nums2.Length;
        for (int i = 0; i &#x3C; n1; i++)
        {
            int max = -1;
            int find = 0;
            int value = nums1[i];

            for ( int j = 0 ; j &#x3C; n2; j++)
            {
                if (value == nums2[j])
                {
                    find = j;
                    break;
                };
            }
            if (find != n2)
            {
                for ( int k = find; k &#x3C; n2; k++)
                {
                    if (value &#x3C; nums2[k])
                    {
                        max = nums2[k];
                        break;
                    }
                }
            }
            stack.Add(max);
        }
        return stack.ToArray();
    }
</code></pre></div></div><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-0 ant-col-md-6"><div><div class=""><div class="ant-anchor-wrapper dendron-toc" style="max-height:calc(100vh - 64px);z-index:1"><div class="ant-anchor"><div class="ant-anchor-ink"><span class="ant-anchor-ink-ball"></span></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#相关题目" title="相关题目">相关题目</a></div></div></div></div></div></div></div></div></div></div></div><div class="ant-divider ant-divider-horizontal" role="separator"></div><footer class="ant-layout-footer" style="padding:0 24px 24px"></footer></main></section></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"note":{"id":"xh52bggd05ofgonrdag8z5u","title":"Stack","desc":"","updated":1670242188649,"created":1670066099552,"custom":{},"fname":"self.reading.grace.data-structure.stack","type":"note","vault":{"fsPath":".","selfContained":true,"name":"Notes"},"contentHash":"86e4d167dd37bebe4d0759b553b3a014","links":[{"type":"wiki","from":{"fname":"self.reading.grace.data-structure.stack","id":"xh52bggd05ofgonrdag8z5u","vaultName":"Notes"},"value":"tags.Data-Structure","alias":"#Data-Structure","position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":16,"offset":16},"indent":[]},"xvault":false,"to":{"fname":"tags.Data-Structure"}},{"type":"wiki","from":{"fname":"self.reading.grace.data-structure.stack","id":"xh52bggd05ofgonrdag8z5u","vaultName":"Notes"},"value":"tags.Stack","alias":"#Stack","position":{"start":{"line":2,"column":17,"offset":17},"end":{"line":2,"column":23,"offset":23},"indent":[]},"xvault":false,"to":{"fname":"tags.Stack"}}],"anchors":{"相关题目":{"type":"header","text":"相关题目","value":"相关题目","line":15,"column":0,"depth":3}},"children":[],"parent":"kyvtf0hst75lwr1iw9glvhr","data":{}},"body":"\u003ch1 id=\"stack\"\u003eStack\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#stack\"\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e\u003ca title=\"Private\" href=\"https://wiki.dendron.so/notes/hfyvYGJZQiUwQaaxQO27q.html\" target=\"_blank\" class=\"private\"\u003e#Data-Structure (Private)\u003c/a\u003e \u003ca title=\"Private\" href=\"https://wiki.dendron.so/notes/hfyvYGJZQiUwQaaxQO27q.html\" target=\"_blank\" class=\"private\"\u003e#Stack (Private)\u003c/a\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e后进先出，先进后出，操作受限的线性表\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e数组实现的栈=顺序栈，链表实现的栈=链式栈\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e栈的相关 leetcode 题目：20,155,232,844,224,682,496.\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"相关题目\"\u003e相关题目\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#相关题目\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e20 题目描述：有效的括号,给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre class=\"language-c#\"\u003e\u003ccode class=\"language-c#\"\u003e public class Solution {\n     public bool IsValid(string s) {\n         Stack\u0026#x3C;char\u003e sc = new Stack\u0026#x3C;char\u003e();\n         Dictionary\u0026#x3C;char, char\u003e otherChar = new Dictionary\u0026#x3C;char, char\u003e() { { '(', ')' }, { '[',']' },{ '{','}'} };\n         foreach( var item in s)\n         {\n             if(otherChar.ContainsKey(item)) sc.Push(item);\n             else\n             {\n                 if (sc.Count == 0) return false;\n                 char c = sc.Pop();\n                 if (otherChar[c] != item) return false;\n             }\n\n         }\n         return sc.Count == 0;\n\n     }\n }\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e155 题描述：设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e实现 MinStack 类:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMinStack() 初始化堆栈对象。\u003c/li\u003e\n\u003cli\u003evoid push(int val) 将元素 val 推入堆栈。\u003c/li\u003e\n\u003cli\u003evoid pop() 删除堆栈顶部的元素。\u003c/li\u003e\n\u003cli\u003eint top() 获取堆栈顶部的元素。\u003c/li\u003e\n\u003cli\u003eint getMin() 获取堆栈中的最小元素。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre class=\"language-c#\"\u003e\u003ccode class=\"language-C#\"\u003epublic class MinStack {\n\n    private int?[] _array;\n    private int _size = 0;\n\n    private const int _defaultCapacity = 10;\n\n    public MinStack()\n    {\n        _array = new int?[_defaultCapacity];\n    }\n\n    public void Push(int val)\n    {\n        if (_array.Length == _size)\n        {\n            int?[] newArray = new int?[_size * 2];\n            Array.Copy(_array, newArray, _size);\n            _array = newArray;\n        }\n        _array[_size++] = val;\n    }\n\n    public void Pop()\n    {\n        _array[--_size] = null;\n    }\n\n    public int Top()\n    {\n        return (int)_array[_size - 1];\n    }\n\n    public int GetMin()\n    {\n        return (int)_array.Min();\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e占用内存最小的解法\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre class=\"language-c#\"\u003e\u003ccode class=\"language-C#\"\u003epublic class MinStack {\n\n    Stack\u0026#x3C;int\u003e stack;\n    Stack\u0026#x3C;int\u003e minStack;\n\n    public MinStack()\n    {\n        stack= new Stack\u0026#x3C;int\u003e();\n        minStack= new Stack\u0026#x3C;int\u003e();\n    }\n\n    public void Push(int val)\n    {\n        stack.Push(val);\n        if(minStack.Count == 0 || minStack.Peek() \u003e= val)\n        {\n            minStack.Push(val);\n        }\n    }\n\n    public void Pop()\n    {\n        if(minStack.Count!= 0 \u0026#x26;\u0026#x26; stack.Pop() == minStack.Peek())\n        {\n            minStack.Pop();\n        }\n    }\n\n    public int Top()\n    {\n        return stack.Peek();\n    }\n\n    public int GetMin()\n    {\n        return minStack.Peek();\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e232 题，用栈实现队列。题目描述：请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e实现 MyQueue 类：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003evoid push(int x) 将元素 x 推到队列的末尾\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eint pop() 从队列的开头移除并返回元素\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eint peek() 返回队列开头的元素\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eboolean empty() 如果队列为空，返回 true ；否则，返回 false\n说明：\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre class=\"language-c#\"\u003e\u003ccode class=\"language-C#\"\u003epublic class MyQueue {\n\n    Stack\u0026#x3C;int\u003e leftStack;\n    Stack\u0026#x3C;int\u003e rightStack;\n\n    public MyQueue()\n    {\n        leftStack= new Stack\u0026#x3C;int\u003e();\n        rightStack= new Stack\u0026#x3C;int\u003e();\n    }\n\n    public void Push(int x)\n    {\n        if(leftStack.Count==0) leftStack.Push(x);\n        else\n        {\n            while(leftStack.Count != 0)\n            {\n                int v = leftStack.Pop();\n                rightStack.Push(v);\n            }\n            leftStack.Push(x);\n            while(rightStack.Count != 0)\n            {\n                int v = rightStack.Pop();\n                leftStack.Push(v);\n            }\n        }\n\n        //另一种解题思路\n        while(leftStack.Count !=0) rightStack.Push(leftStack.Pop());\n        leftStack.Push(x);\n        while(rightStack.Count != 0) leftStack.Push(rightStack.Pop());\n    }\n\n    public int Pop()\n    {\n        return leftStack.Pop();\n    }\n\n    public int Peek()\n    {\n        return leftStack.Peek();\n    }\n\n    public bool Empty()\n    {\n        return leftStack.Count == 0;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e844 题目：给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。\u003c/p\u003e\n\u003cp\u003e注意：如果对空文本输入退格字符，文本继续为空。\n示例 1：\u003c/p\u003e\n\u003cp\u003e输入：s = \"ab#c\", t = \"ad#c\"\n输出：true\n解释：s 和 t 都会变成 \"ac\"。\n示例 2：\u003c/p\u003e\n\u003cp\u003e输入：s = \"ab##\", t = \"c#d#\"\n输出：true\n解释：s 和 t 都会变成 \"\"。\n示例 3：\u003c/p\u003e\n\u003cp\u003e输入：s = \"a#c\", t = \"b\"\n输出：false\n解释：s 会变成 \"c\"，但 t 仍然是 \"b\"。\u003c/p\u003e\n\u003cpre class=\"language-c#\"\u003e\u003ccode class=\"language-C#\"\u003epublic class Solution {\n    public bool BackspaceCompare(string s, string t) {\n        Stack\u0026#x3C;char\u003e l = new Stack\u0026#x3C;char\u003e();\n        Stack\u0026#x3C;char\u003e r = new Stack\u0026#x3C;char\u003e();\n\n        foreach(var item in s)\n        {\n            if(item == '#'){\n                 if(l.Count \u003e 0) l.Pop();\n            }\n            else l.Push(item);\n        }\n        foreach(var item in t)\n        {\n            if (item == '#' ){\n                if(r.Count \u003e 0) r.Pop();\n            }\n            else r.Push(item);\n        }\n        if (l.Count != r.Count) return false;\n        while(l.Count \u003e 0){\n            if(l.Pop() != r.Pop()) return false;\n        }\n        return true ;\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e题目 682，棒球比赛：你现在是一场采用特殊赛制棒球比赛的记录员。这场比赛由若干回合组成，过去几回合的得分可能会影响以后几回合的得分。\u003c/p\u003e\n\u003cp\u003e比赛开始时，记录是空白的。你会得到一个记录操作的字符串列表 ops，其中 ops[i] 是你需要记录的第 i 项操作，ops 遵循下述规则：\u003c/p\u003e\n\u003cp\u003e整数 x - 表示本回合新获得分数 x\n\"+\" - 表示本回合新获得的得分是前两次得分的总和。题目数据保证记录此操作时前面总是存在两个有效的分数。\n\"D\" - 表示本回合新获得的得分是前一次得分的两倍。题目数据保证记录此操作时前面总是存在一个有效的分数。\n\"C\" - 表示前一次得分无效，将其从记录中移除。题目数据保证记录此操作时前面总是存在一个有效的分数。\n请你返回记录中所有得分的总和。\u003c/p\u003e\n\u003cpre class=\"language-c#\"\u003e\u003ccode class=\"language-c#\"\u003epublic int CalPoints(string[] operations) {\n        Stack\u0026#x3C;int\u003e stack = new Stack\u0026#x3C;int\u003e();\n        foreach (var s in operations)\n        {\n            if (s == \"+\")\n            {\n                int num1 = stack.Pop();\n                int num2 = stack.Peek();\n                stack.Push(num1);\n                stack.Push(num1 + num2);\n            }\n            else if (s == \"D\")\n            {\n\n                int num1 = stack.Peek();\n                stack.Push(2 * num1);\n            }\n            else if (s == \"C\")\n            {\n\n                stack.Pop();\n            }\n            else stack.Push(int.Parse(s));\n        }\n        int sum = 0;\n        while (stack.Any())\n        {\n            sum += stack.Pop();\n        }\n        return sum;\n    }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e题目 496，下一个更大元素：\nnums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。\u003c/p\u003e\n\u003cp\u003e给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中 nums1 是 nums2 的子集。\u003c/p\u003e\n\u003cp\u003e对于每个 0 \u0026#x3C;= i \u0026#x3C; nums1.length ，找出满足 nums1[i] == nums2[j] 的下标 j ，并且在 nums2 确定 nums2[j] 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 -1 。\u003c/p\u003e\n\u003cp\u003e返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i] 是如上所述的 下一个更大元素 。\u003c/p\u003e\n\u003cp\u003e示例 1：\u003c/p\u003e\n\u003cp\u003e输入：nums1 = [4,1,2], nums2 = [1,3,4,2].\n输出：[-1,3,-1]\n解释：nums1 中每个值的下一个更大元素如下所述：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。\u003c/li\u003e\n\u003cli\u003e1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。\u003c/li\u003e\n\u003cli\u003e2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre class=\"language-c#\"\u003e\u003ccode class=\"language-c#\"\u003epublic int[] NextGreaterElement(int[] nums1, int[] nums2) {\n        List\u0026#x3C;int\u003e stack = new List\u0026#x3C;int\u003e();\n        int n1 = nums1.Length;\n        int n2 = nums2.Length;\n        for (int i = 0; i \u0026#x3C; n1; i++)\n        {\n            int max = -1;\n            int find = 0;\n            int value = nums1[i];\n\n            for ( int j = 0 ; j \u0026#x3C; n2; j++)\n            {\n                if (value == nums2[j])\n                {\n                    find = j;\n                    break;\n                };\n            }\n            if (find != n2)\n            {\n                for ( int k = find; k \u0026#x3C; n2; k++)\n                {\n                    if (value \u0026#x3C; nums2[k])\n                    {\n                        max = nums2[k];\n                        break;\n                    }\n                }\n            }\n            stack.Add(max);\n        }\n        return stack.ToArray();\n    }\n\u003c/code\u003e\u003c/pre\u003e","noteIndex":{"id":"c1cwtzujmgfsd4mq3t3tytu","title":"Root","desc":"","updated":1670036340835,"created":1670036340835,"custom":{"nav_order":0,"permalink":"/"},"fname":"root","type":"note","vault":{"fsPath":".","selfContained":true,"name":"Notes"},"contentHash":"e2031e0d4f5f68229f977757318dd889","links":[],"anchors":{"welcome-to-dendron":{"type":"header","text":"Welcome to Dendron","value":"welcome-to-dendron","line":7,"column":0,"depth":1},"lookup":{"type":"header","text":"Lookup","value":"lookup","line":11,"column":0,"depth":2}},"children":["6dtg3w55w1x7r0sawmob7lv","cjgvkorp7u78p38mx3ptzlo","d0xazr16kuzwxb3uao60g8m","k1twbj4e5z32nbsnio3j6zy","n99az6y3n94r0t8e1crppv2","43t92vxhgipu9o19mdb3mfn"],"parent":null,"data":{},"body":"# Welcome to Dendron\n\nThis is the root of your dendron vault. If you decide to publish your entire vault, this will be your landing page. You are free to customize any part of this page except the frontmatter on top.\n\n## Lookup\n\nThis section contains useful links to related resources.\n\n- [Getting Started Guide](https://link.dendron.so/6b25)\n- [Discord](https://link.dendron.so/6b23)\n- [Home Page](https://wiki.dendron.so/)\n- [Github](https://link.dendron.so/6b24)\n- [Developer Docs](https://docs.dendron.so/)\n"},"collectionChildren":null,"customHeadContent":null,"config":{"version":5,"dev":{"enablePreviewV2":true,"enableSelfContainedVaults":true},"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":true,"vaultSelectionModeOnCreate":"smart","leaveTrace":false,"bubbleUpCreateNew":true,"fuzzThreshold":0.2}},"randomNote":{},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"copyNoteLink":{"aliasMode":"title"},"templateHierarchy":"template"},"workspace":{"vaults":[{"fsPath":".","selfContained":true,"name":"Notes"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"task":{"name":"task","dateFormat":"y.MM.dd","addBehavior":"asOwnDomain","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"taskCompleteStatus":["done","x"],"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link"},"graph":{"zoomSpeed":1,"createStub":false},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"enableUserTags":true,"enableHashTags":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":false,"enableEditorDecorations":true,"maxPreviewsCached":10,"maxNoteLength":204800,"enableFullHierarchyNoteTitle":false},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enablePrettyRefs":true,"enableKatex":true,"automaticallyShowPreview":false},"publishing":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"copyAssets":true,"siteHierarchies":["root"],"writeStubs":false,"siteRootDir":"docs","seo":{"title":"Dendron","description":"Personal Knowledge Space"},"github":{"enableEditLink":true,"editLinkText":"Edit this page on GitHub","editBranch":"main","editViewMode":"tree"},"enableSiteLastModified":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enableRandomlyColoredTags":true,"enableTaskNotes":true,"enablePrettyLinks":true,"searchMode":"search","siteUrl":"https://i-jade.github.io","siteFaviconPath":"favicon.ico","siteIndex":"root"}}},"__N_SSG":true},"page":"/notes/[id]","query":{"id":"xh52bggd05ofgonrdag8z5u"},"buildId":"UBg_0AtPYlRIOJ6te7oHW","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>